

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=295855&viewfull=1#post295855

*pilgrim*

Итак, плату развёл. Разводил один к одному по сканам платы. Должен отметить,
что, как итог, в приведённой ранее схеме и схеме которая у меня получилась по
плате есть небольшие отличия, хотя и незначительные, стоит отметить, что часть
из них логична, т.е. в схеме ранее были заведомо непонятные моменты. Но есть и
такие исправления, которые касаются распиновки разъёма под HDD, а именно
добавлен один вывод GND, и другие выводы на +5В. Поэтому имеет смысл свериться
с распиновкой HDD, на тот случай если уже в самой плате были ошибки, а не в
схеме. Ниже привожу архив со схемой (скорректированной по плате), разведённой
платой и библиотекой элементов. Всё было сделано в PCAD-2006.

Добавлю ещё одно отличие, про которое забыл упомянуть ранее - в окончательной
схеме на 2 конденсатора меньше.

(HDD.rar)


---
*Alex_K*

1. В верхней части платы сделать "ушко", для того чтобы закручивать туда разъем IDCC-40:

2. 21 вывод IDE отсоединить от земли и оставить висеть в воздухе. Этот вывод
   используется в более поздних моделях для запроса DMA, а УКНЦ-шный контроллер
   этого не использует:

3. 38 вывод IDE присоединить к +5 вольтам. Это вход CS1, используется для
  выбора регистров Alternate status/Device control и Drive address
  (соответственно 3F6 и 3F7 на PC). В контроллере выбор этих регистров не
  реализован и лучше этот вывод присоединить к +5, а то неизвестно как будет
  реагировать некоторые модели винчестеров и CF-карт на висящий в воздухе вывод:

4. Ну и соответственно добавить один конденсатор емкость 680 nF для задержки
   сигнала SYNC, присоединяется между выводами 10 (GND) и 11 (C) регистров
   1533ИР22. В разводке от "ЭР" этого кондера нет, его припаивали потом на задней
   стороны платы к выводам регистра, по всей видимости не на всех экземплярах УКНЦ
  контроллер работал устойчиво без этого конденсатора:


---
*dk_spb*

А я бы очень настоятельно просил переделать платку под разъем для HDD типа LBH ("лежачий" IDC).
Кому надо - воткнет туда кабелек и в HDD, а другие могут воткнуть туда сразу
переходник на CD или CD. То есть разъем контактами должен смотреть вглую платы
со стороны деталей. Такое возможно? Или трудоемко? Ну всё-равно лучше под
разъем, даже если он будет смотреть в другую сторону. 


---
*Alex_K*

dk_spb, если не стоит 155РЕ3, то стоит снять резисторную сборку, но тогда надо
ставить резистор подтяжки на выход 3 155ЛА13.
А если пустая 155РЕ3 выдает 0xFF, то можно поставить и её. 

---
 *Alex_K*
А вторая половина 155РЕ3 заполнена 0xFF?
---
*dp_spb*

Alex_K, И как же мне теперь с Вами рассчитываться?
Коньяк я вроде уже и так Вам должен за прошлый раз....
Все заработало после зачистки второй половины ре3.
Даже загрузилось сразу с винта. 


---
*Alex_K*

Ну да, там же вывод А4 ПЗУ подключен к адресному выводу А12, т.е. когда адрес в
диапазоне 100000-107777, то выбирается одна половина ПЗУ, а когда адрес в
диапазоне 110000-117777, то выбирается другая половина ПЗУ, но одновременно
выбирается и винчестер, поэтому ПЗУ в этом случае должно выдавать 0xFF. 


---
*olegh*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=385788&viewfull=1#post385788

> Но вопрос о том как различать к какому драйверу относится
> первый сектор винчестера -- пока остаётся открытым.

Да, по мастер-блоку не догадаешься однозначно. Извините, не подумал, когда проектировал. У меня в WD: есть обратная совместимость с ID:, но не более того.

И раз зашёл вопрос ID/WD, скажу тут, как на УК-хе копировать с винта на винт (контроллеры одинаковые):

1. WD-контроллер (основной) суём в cassette-1
2. контроллер с пустым винтом - в cassette-2
3. Boot WD0; Run WDX, разметили диск во втором контроллере.
4. Запускаем программу ID2.SAV - это хаченый резидент от ЭР.
Цепляется к кассете-2.
Должен быть на моих дисках-архивах, у меня была на SY:
5. install ID; Load ID
6. Init ID0:, etc
7. cop/sys wd0: id0:
8. cop/boot:id0:wd.sys id0:
Всё, загрузочный раздел скопирован на ID0. При загрузке - он будет использовать firmware WD:
ID в этом случае - просто вспомагательный драйвер... 

---
*nzeemen*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=386648&viewfull=1#post386648


 Выяснил алгоритм подсчёта CRC для HDD home block, вот он:


    Sb.Tst:
        jsr	r2,crcclc
        .word	377
        add	(r3),r5
        bis	r4,r5
        Return
    Sb.clc:
        jsr	r2,crcclc
        .word	376
    ;	inc	r5
    ;	neg	r5
        com	r5
        neg	r4
        mov	r4,(r3)+
        mov	r5,(r3)
        Return
    crcclc:
        mov	(r2)+,r0
        mov	#SbBuf,r1
        mov	r1,r3
        clr	r4
        clr	r5
    2$:	add	(r3)+,r4
        adc	r5
        sob	r0,2$
        Rts	r2


Или, в переложении на C/С++:

    static DWORD GetHomeBlockChecksum(void* buffer)
    {
        WORD* p = (WORD*) buffer;
        DWORD crc = 0;
        for (int i = 0; i < 255; i++)
        {
            crc += (DWORD) *p;
            p++;
        }
        crc += ((DWORD)*p) << 16;

        return crc;
    }


---
*Patron*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=387385&viewfull=1#post387385


Насколько я понял - предложенная Вами функция возвращает не 32-разрядную контрольную сумму первых 254 слов блока, а инвертированный признак её корректности ( т.е. "ноль", если 32-разрядная контрольная сумма первых 254 слов совпадает со значением последних 2-х слов, рассматриваемых как 32-разрядное целое, и "не ноль" в иных случаях ).

Значение контрольной суммы вычисляет (как я понял) следующая функция:


    DWORD CalculateHomeBlockChecksum(void* buffer)
    {
        DWORD crc = 0;
        
        for (int i = 0; i < 254; i++)
        {
            crc += ( (WORD*) buffer )[i];
        }
        return crc * (-1);
    }


Сохранённое в блоке значение контрольной суммы возвращает (если не ошибаюсь) следующая функция:

    DWORD GetHomeBlockChecksum(void* buffer)
    {
        return ( (DWORD*) buffer )[127];
    }


---
*form*

Драйверы для RT-11 V05.07.

(wd57.zip)

С поддержкой device timeout, без поддержки, с поддержкой 64 разделов (одним
драйвером [не проверял]), без поддержки...

Если нет резидентной части в памяти ПП, драйвер не инсталится.

Очень тестовая версия, не решающая всех проблем, но вполне стабильно работающая если не лезть к флопу

Драйвер можно использовать в старых версиях RT-11, но при этом не стоит пихать
драйвер с поддержкой 64 разделов в RT-11 старее 5.6.
В RT-11 5.6 и новее драйвер будет работать независимо от поддержки extended units системой. 

---
*form*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=389643&viewfull=1#post389643

На случай если кому захочется свой драйвер делать...

Принцип такой (при загруженной резидентной части со стороны ПП):

@#144 содержит адрес обработчика прерываний (WDINT к примеру), выше этого
адреса должно быть 4 слова занятых пофигу чем, 5е слово выше должно содержать
адрес элемента очереди I/O (берется из WDCQE). В адрес 146 пишется 342 на чем
собственно функция драйвера и заканчивается - все остальное делается на стороне
ПП, по окончанию вызывается прерывание (при этом приоритет процессора глубоко
пофигу, а если есть какие прерывания в очереди - они слетят ибо прерывание
эмулируется временной пересадкой адреса в @#24 и эмуляцией сбоя питания). Байт
@#146 при этом будет содержать 0 (успешное завершение) или 1 (ошибка).

Обработчик со стороны ПП отрабатывает чтение, запись и SPFUN #373 (вернуть
размер устройства). При этом номер устройства вроде (детально не всматривался)
передается в поле Q$UNIT целиком, а код функции - в чистом виде в поле Q$FUNC.
Для номеров устройств больше 7 это не совпадает со способом, используемым в
RT-11 - нужно руками преобразовать к данному виду.

в общем случае примерно так:

            .BLKW   1                       ;СЮДА ПИШЕТСЯ АДРЕС ЭЛЕМЕНТА ОЧЕРЕДИ
            .BLKW   3                       ;3 СЛОВА ПРОПУСКА

    ;В ЭТОМ МЕСТЕ НЕЯВНО НАХОДИТСЯ 'RETURN' ИЛИ 'BR' (ЕСЛИ УКАЗАТЬ ТРЕТИЙ АРГУМЕНТ
    ;В .DRAST

            .DRAST  WD,4
            MOV     WDCQE,R4                ;R4 -> АДРЕС ЭЛЕМЕНТА ОЧЕРЕДИ
            BISB    @#146,@-(R4)            ;УСТАНАВЛИВАЕМ СТАТУС В CSW
            .DRFIN  WD                      ;ЗАВЕРШАЕМ I/O


В оригинале после .DRBEG делается отступ на одно слово назад и пишется команда "MOV #342,@#146" после которой делается "RETURN". В этом случае если сразу после RETURN идет .DRAST, слово WDCQE придется как раз в то место которого ожидает обработчик в ПП, однако такая конструкция будет работать только в мониторе без поддержки device timeout.

---------- Post added at 10:23 ---------- Previous post was at 10:09 ----------

И для ручного выполнения I/O например из отладчика, что '@' нам рисует...
Формат элемента очереди, используемый резидентной частью:

    оффсет  размер  назначение
    +0      слово   номер блока
    +2      байт    код SPFUN или 0 для чтения/записи
    +3      байт    номер устройства
    +4      слово   адрес буфера
    +6      слово   количество слов (со знаком минус для записи)


---
*olegh*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=395828&viewfull=1#post395828


Господа хорошие,
Благодаря dk_spb, который мне сподобился прислать плату УК-НЦ, я запустил
машину после ~14летнего перерыва. Полез смотреть на исходники, что у меня есть.

Что найдено:
1. WDX/WDXR - версия 1.15. Разницы с 1.14 не помню, но думаю, небольшая.
2. WDBOOT (резидент) - v1.10 - как я понимаю, у вас такая же.
3. Копая драйвер и WDBOOT, со скрипом мозга вспомнил про интересный механизм,
который я приделал к своему драйверу винчестера. Поделюсь им тут.

Итак, есть проблема: кое-какие старые игрушки для УК-НЦ написаны через одно
место, не захватывают память в ПП, а сразу копируют свой резидент в верхние
адреса доступной памяти, не глядя, есть ли там чего, или нет.
То есть они думают "я тут один, самый первый, значится, память свободна"
Если там уже находятся другие резидентные программы, которые взяли память
корректным способом, то естественно, получается полный швах - эти игрушки
перетирают собою всё, что можно. Естественно, под раздачу попадает в первую
очередь резидент винчестера.
Чтоб забороть этот глюк, в firmware вставлен следующий хак:
В мастер-блок диска (где геометрия, партиции и тп) по смещению 0126 лежит 0.
Если туда положить N > 0, то перед захватом куска памяти для резидента винчестера,
будет захвачен ещё один - просто кусок памяти в верхних адресах, размером N байт.
А сам резидент винчестера, и корректные программы, которые сажают свои
резиденты, разместятся уже ниже этого буфера-пустышки.

Потом, когда система загружена, и все другие резиденты установлены, можно сказать "Set WD: Free".
Драйвер освободит захваченый кусок памяти в верхних адресах.

В результате, место в верхних адресах будет свободно, и некорректные игрушки
будут работать, и не убивать нормальных резидентов.

Сразу скажу, что я не помню, что за игрушки - были в каких-то школьных пакетах,
и с довольно неплохой графикой. 

---

*Alex_K*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=425025&viewfull=1#post425025

 CE0 - сигнал разрешения работы системного ПЗУ в диапазоне 100000-117777,
  если он стоит, то ПЗУ разрешена, иначе запрещена. 
Т.к. МПИ инверсная, то "электрически" при запрещенном ПЗУ там будет единица. 
Такая же история и с CE3, только этот сигнал используется для выбора слота (1 или 2).

Соответственно так как контроллер работает в окне "100000-117777", то он активируется при:
* запрещенном СПЗУ (CE0=0, "электрически" 1),
* выбранном слоте (CE3),
* адрес входит в "окно" (A15-A13=100, "электрически" 011).
* Адрес естественно защелкивается по спаду SYNC.
* Сигналы CE0 и CE3 не защелкиваются, они все время на разъеме.

А линией A12 (защелкнутой) уже выбирается или:
* ПЗУ (адреса 100000-107777), или
* регистры винчестера (110000-117777)


---
*form*

> не дадите ссылочку на адекватное описание МПИ?
> а то по моим описаниям SYNC активен на весь цикл обмена,
> а разделение адрес-данные происходит по фронтам DIN или DOUT 

Берется описание любого подходящего проца на bitsavers, там все есть в наглядном виде. Названия сигналов только надо будет сопоставить, но это не сложно.

KDJ11-B подойдет. 
    http://bitsavers.trailing-edge.com/pdf/dec/pdp11/1173/EK-KDJ1B-UG_KDJ11-B_Nov86.pdf

---

*Alex_K*

В описании все верно - сначала выставляется адрес (электрически он инверсный).
Затем по спаду SYNC этот адрес защелкивается во внутренних регистрах
контроллера. Через некоторое время на линии адрес-данные выставляются данные и
потом сигнал DOUT или эти линии переходят у процессора в режим входов и
выставляется сигнал DIN. Внешнее устройство отработав, выставляет сигнал RPLY
(спад сигнала). Получив RPLY процессор снимает DIN/DOUT. Вслед за этим
устройство должно снять RPLY, а процессор SYNC. Так что SYNC действительно
активен во время всего обмена, он служит не только защелкой адреса, но и
индикатором адресного обмена, т.к. бывают еще процедуры чтения вектора
прерывания, а у 1801ВМ2 есть еще чтение безадресного регистра.

А по литературке - поищите книгу Захарова "Электроника-60", доку на 1806ВМ2, там все это описано. 


---
*form*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=425058&viewfull=1#post425058

На случай если кому захочется побаловаться, исходник драйвера, работающего в
RT-11 V05.05 и новее. Мне лень дальше ковыряться

Использует библиотеку SYSTEM от последних версий RT-11. 
Собирать в RT-11 V5.6/5.7. SETов нет. Оптимизации нет. Подгрузки кода в ПП нет.

Для системы с поддержкой device timeout раскоментировать TIM$IT=1.
Для поддержки 64 устройств одним драйвером раскоментировать UNI$64=1 
(драйвер будет работать и в системах без поддержки 64 устройств).

Сборка:

    .MAC WD

    .LIN/EXE:WD.SYS/NOBI WD/BOU:1000
    Boundary section? SETOVR

Не помню точно последний это вариант или нет. Лень УКНЦу собирать 

(wd.txt)

---

## Проблемы с эмулятором IDE

*nzeemin*
При загрузке ПЗУшкой от "Электронных работ" (трасса записи в порты винчестера):

    HDD Write 1f4 <-- 0xffff
    HDD Write 1f4 <-- 0xff00
    HDD Write 1f4 <-- 0xffff
    HDD Write 1f4 <-- 0xff00
    HDD Write 1f6 <-- 0xff00
    HDD Write 1f5 <-- 0xff00
    HDD Write 1f4 <-- 0xff00
    HDD Write 1f3 <-- 0xff01
    HDD Write 1f2 <-- 0xff01
    HDD Write 1f7 <-- 0x0020
    HDD COMMAND 20 (READ MULT): C=0, H=0, SN=1, SC=1
    HDD Write 1f2 <-- 0xf522
    HDD Write 1f6 <-- 0x0009
    HDD Read sector complete
    HDD Write 1f7 <-- 0x0091
    HDD COMMAND 91 (SET CONFIG): H=9, SC=33

Вот здесь непонятка -- получается что сначала задаются параметры следующей
команды, но затем завершается передача сектора, что приводит к декременту
`sector_count` (SC, порт 1F2). В результате команда 91h получает параметр SC=33,
что конечно неверно и в дальнейшем приводит к ошибкам позиционирования.

Либо я тут неправильно понимаю логику SC и он должен уменьшаться до завершения
передачи данных сектора -- но неясно в какой момент.
<...>
UPD: В общем, сделал пока декремент счётчика непосредственно перед началом
чтения -- вроде как работает.


*shattered*

https://zx-pk.ru/threads/12218-vinchester-uknts.html?p=884395&viewfull=1#post884395

наступил на эти же грабли, делая эмуляцию этих контроллеров в MAME. эмуляция
ATA/IDE как таковая там уже есть, но пока не стыкуется с УКНЦ 

    [:ide]    2.453573 at ':subcpu' (26102): IDE W                   [:ide] 1f4 <- 0000 (ffff) & 177777
    [:ide]    2.453576 at ':subcpu' (26104): IDE R                   [:ide] 1f4 == 00ff (ff00)
    [:ide]    2.453583 at ':subcpu' (26112): IDE W                   [:ide] 1f4 <- 00ff (ff00) & 177777
    [:ide]    2.453586 at ':subcpu' (26114): IDE R                   [:ide] 1f4 == 0000 (ffff)
    [:ide]    2.486194 at ':subcpu' (26102): IDE W                   [:ide] 1f4 <- 0000 (ffff) & 177777
    [:ide]    2.486196 at ':subcpu' (26104): IDE R                   [:ide] 1f4 == 00ff (ff00)
    [:ide]    2.486204 at ':subcpu' (26112): IDE W                   [:ide] 1f4 <- 00ff (ff00) & 177777
    [:ide]    2.486207 at ':subcpu' (26114): IDE R                   [:ide] 1f4 == 0000 (ffff)
    [:ide]    2.486246 at ':subcpu' (25404): IDE R                   [:ide] 1f7 == 0052 (ffad)
    [:ide]    2.486249 at ':subcpu' (25406): IDE R                   [:ide] 1f7 == 0050 (ffaf)
    [:ide]    2.486257 at ':subcpu' (25416): IDE W                   [:ide] 1f6 <- 00ff (ff00) & 177777
    [:ide]    2.486261 at ':subcpu' (25420): IDE W                   [:ide] 1f5 <- 00ff (ff00) & 177777
    [:ide]    2.486264 at ':subcpu' (25422): IDE W                   [:ide] 1f4 <- 00ff (ff00) & 177777
    [:ide]    2.486269 at ':subcpu' (25426): IDE W                   [:ide] 1f3 <- 00fe (ff01) & 177777
    [:ide]    2.486273 at ':subcpu' (25430): IDE W                   [:ide] 1f2 <- 00fe (ff01) & 177777
    [:ide]    2.486276 at ':subcpu' (25432): IDE R                   [:ide] 1f1 == 0001 (fffe)
    [:ide]    2.486283 at ':subcpu' (25442): IDE W                   [:ide] 1f7 <- ffdf (0020) & 177777
    [:ide:ide:0:hdd] IDE Read multiple: C=0 H=0 S=1 LBA=0 count=1
    [:ide]    2.486286 at ':subcpu' (25444): IDE R                   [:ide] 1f7 == 00d0 (ff2f)
    [:ide]    2.486291 at ':subcpu' (25444): IDE R                   [:ide] 1f7 == 0058 (ffa7)
    [:ide]    2.486296 at ':subcpu' (25452): IDE R                   [:ide] 1f7 == 0058 (ffa7)
    [:ide]    2.486310 at ':subcpu' (25534): IDE R                   [:ide] 1f0 == 0a22 (f5dd)
    [:ide]    2.486326 at ':subcpu' (25552): IDE W                   [:ide] 1f2 <- 0add (f522) & 177777
    [:ide:ide:0:hdd] ':subcpu' (25552): :ide:ide:0:hdd dev 0 write_cs0 0002 0022 00ff ignored (DRQ) command 20
    [:ide]    2.486338 at ':subcpu' (25566): IDE W                   [:ide] 1f6 <- fff6 (0009) & 177777
    [:ide:ide:0:hdd] ':subcpu' (25566): :ide:ide:0:hdd dev 0 write_cs0 0006 0009 00ff ignored (DRQ) command 20
    <...>
    [:ide]    2.490648 at ':subcpu' (25736): IDE W                   [:ide] 1f7 <- ff6e (0091) & 177777
    [:ide:ide:0:hdd] IDE Set configuration (1 heads, 0 sectors)


в результате видим:

P.S. ссылку на образ оказалось не так просто найти -- http://archive.pdp-11.org.ru/EMULATO...btl_hdd_wd.rar

*Alex_K*

Ну там немного другие грабли были - ошибка при переходе на другую дорожку,
почитайте внимательно. А здесь почему-то не воспринимаются команды для
установки геометрии диска. Отчего-то игнорируется запись в порты 1F2 и 1F6,
может потому-что из буфера прочитан не весь сектор. 

Спецификацию обязательно нужно прочесть. Насчет различных экземпляров - у меня
контроллер с прошивкой от Олега Ховайко, так у меня работали самые разные винчи
и IDE Flash-карты без проблем.

*shattered*

таки да, отдельные команды можно посылать, не дожидаясь снятия DRQ, и 0x91 в их
числе (via http://hddguru.com/documentation/200...ATA-ATAPI-1/):

    10 Protocol overview

    Commands can be grouped into different classes according to the protocols
    followed for command execution. The command classes with their associated
    protocols are defined below.

    For all commands, the host first checks if BSY=1, and should proceed no
    further unless and until BSY=0. For most commands, the host will also wait
    for DRDY=1 before proceeding. Those commands shown with DRDY=x can be
    executed when DRDY=0.

    <...>

    10.3 Non-data commands

    This class includes:
    - Execute drive diagnostic (DRDY=x);
    - Idle;
    - Initialize drive parameters (DRDY=x);
    - Read power mode;
    - Read verify sector(s);
    - Recalibrate;
    - Seek;
    - Set features;
    - Set multiple mode;
    - Standby.

    Execution of these commands involves no data transfer.

    a) The host writes any required parameters to the Features, Sector Count, Sector Number, Cylinder, and Drive/Head registers.
    b) The host writes the command code to the Command Register.
    c) The drive sets BSY.
    d) When the drive has completed processing, it clears BSY and asserts INTRQ.
    g) The host reads the Status Register.
    h) The drive negates INTRQ. 


*shattered*

 Оказалось, что WDBOOT дергает основной процессор за ACLO -- дописал это в ядро ВМ2 + еще немного исправлений и...

*nzeemen*

Замечу, что имеющиеся драйверы используют совсем немного IDE-команд, хватило реализации следующего:

    IDE_COMMAND_IDENTIFY -- 0xec
    IDE_COMMAND_READ_MULTIPLE / IDE_COMMAND_READ_MULTIPLE1 -- 0x20/0x21
    IDE_COMMAND_SET_CONFIG -- 0x91
    IDE_COMMAND_WRITE_MULTIPLE / IDE_COMMAND_WRITE_MULTIPLE1 -- 0x30/0x31 

